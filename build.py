#!/usr/bin/env python3
import json
import os
import re
import urllib.parse
from dataclasses import dataclass
from io import BytesIO
from pathlib import Path
from subprocess import check_output, list2cmdline
from typing import Any
from zipfile import ZipFile, ZIP_DEFLATED, ZIP_STORED

import requests
from repro_zipfile import ReproducibleZipFile

ROOT_PATH = Path(__file__).parent
ARTIFACT_PATH = ROOT_PATH / "artifacts"
MAGISK_MODULE_PATH = ROOT_PATH / "magisk-module"
UPDATE_JSON_PATH = ROOT_PATH / "update.json"
CHANGELOG_PATH = ROOT_PATH / "CHANGELOG.md"

MAGISK_MODULE_BUNDLED_PATH = ARTIFACT_PATH / f"{MAGISK_MODULE_PATH.name}.zip"
OPENEUICC_APP_PATH = ARTIFACT_PATH / "app-debug.apk"

OPENEUICC_BASE_URL = "https://gitea.angry.im"
OPENEUICC_ACTOR = "PeterCxy"
OPENEUICC_AUTHOR = "Peter Cai"
OPENEUICC_APP_ID = "openeuicc"
OPENEUICC_APP_NAME = "OpenEUICC"
OPENEUICC_BRANCH = "master"
OPENEUICC_ARTIFACT_NAME = "Debug APKs"

OPENEUICC_REPOSITORY = os.path.join(OPENEUICC_ACTOR, OPENEUICC_APP_NAME)
OPENEUICC_REPO_URL = os.path.join(OPENEUICC_BASE_URL, OPENEUICC_REPOSITORY)
OPENEUICC_PERMS_URL = os.path.join(
    OPENEUICC_BASE_URL, OPENEUICC_REPOSITORY, "raw", "branch", OPENEUICC_BRANCH,
    "privapp_whitelist_im.angry.openeuicc.xml"
)
OPENEUICC_WORKFLOW_RUNS_API_URL = os.path.join(
    OPENEUICC_BASE_URL, "api", "v1", "repos", OPENEUICC_REPOSITORY, "actions", "tasks"
)

GITHUB_WORKSPACE = Path(os.environ.get("GITHUB_WORKSPACE", os.getcwd()))
GITHUB_ACTOR = os.environ.get("GITHUB_ACTOR", "N/A")
GITHUB_EVENT_NAME = os.environ.get("GITHUB_EVENT_NAME")
GITHUB_SERVER_URL = os.environ.get("GITHUB_SERVER_URL", "https://github.com")
GITHUB_REPOSITORY = os.environ.get("GITHUB_REPOSITORY", OPENEUICC_REPOSITORY)
GITHUB_REF = os.environ.get("GITHUB_REF", "refs/heads/main")

MODULE_INSTALLER_URL = "https://github.com/topjohnwu/Magisk/raw/bf4ed29/scripts/module_installer.sh"

CHANGELOG = """\
This release is automatically generated by GitHub Actions.

Update to the commit with hash [{head_sha}]({head_sha_url}) of OpenEUICC repository.
"""


@dataclass(frozen=True)
class WorkflowRun:
    head_sha: str
    run_number: int
    url: str


@dataclass(frozen=True)
class VersionInfo:
    package_name: str
    name: str
    code: int

    @property
    def tag_name(self):
        return self.name.removeprefix("unpriv-")


def get_first_workflow_run() -> WorkflowRun | None:
    response = requests.get(OPENEUICC_WORKFLOW_RUNS_API_URL, params={"page": 1, "limit": 10})
    response.raise_for_status()
    payload: dict[str, Any] = response.json()
    runs = (
        WorkflowRun(head_sha=run["head_sha"], run_number=run["run_number"], url=run["url"])
        for run in payload.get("workflow_runs", [])
        if run["name"] == "build-debug" and
           run["status"] == "success" and
           run["head_branch"] == OPENEUICC_BRANCH
    )
    return next(runs, None)


def download_artifact(artifact_url: str, name: str) -> None:
    artifact_url = os.path.join(artifact_url, "artifacts", urllib.parse.quote(name))
    print("Downloading artifact from", artifact_url)
    response = requests.get(artifact_url)
    response.raise_for_status()
    ARTIFACT_PATH.mkdir(parents=True, exist_ok=True)
    with ZipFile(BytesIO(response.content)) as zip_file:
        print("Extracting artifact path", ARTIFACT_PATH.relative_to(GITHUB_WORKSPACE), "names", zip_file.namelist())
        zip_file.extractall(ARTIFACT_PATH)


def get_file_content(url: str) -> bytes:
    response = requests.get(url)
    response.raise_for_status()
    return response.content


def get_version_info() -> VersionInfo:
    version = os.environ.get("BUILD_TOOLS_VERSION", "latest")
    program = Path(os.environ["ANDROID_HOME"]) / "build-tools" / version / "aapt"
    output = check_output([program, "dump", "badging", str(OPENEUICC_APP_PATH)]).decode("utf-8")
    package_name = re.search(r"name='(?P<name>[^']+)'", output)
    version_name = re.search(r"versionName='(?P<name>[^']+)'", output)
    version_code = re.search(r"versionCode='(?P<code>[^']+)'", output)
    return VersionInfo(
        package_name=package_name.group("name"),
        name=version_name.group("name"),
        code=int(version_code.group("code")),
    )


def build_module_prop(version: VersionInfo) -> str:
    packager_repo_url = os.path.join(GITHUB_SERVER_URL, GITHUB_REPOSITORY)
    module: dict[str, Any] = {
        "id": OPENEUICC_APP_ID,
        "name": OPENEUICC_APP_NAME,
        "version": version.name,
        "versionCode": version.code,
        "author": f"{OPENEUICC_AUTHOR}, Packager by {GITHUB_ACTOR}",
        "description": " ".join([
            "OpenEUICC provides system-level eSIM integration.",
            f"Source Code: {OPENEUICC_REPO_URL}.",
            f"Magisk Module: {packager_repo_url}."
        ]),
        "updateJson": os.path.join(packager_repo_url, "raw", GITHUB_REF, "update.json"),
    }
    return "".join(
        f"{name}={value}\n"
        for name, value in module.items()
    )


def build_update_json(version: VersionInfo, head_sha: str) -> dict[str, str]:
    release_path = os.path.join(GITHUB_SERVER_URL, GITHUB_REPOSITORY, "releases")
    return {
        "version": version.name,
        "versionCode": version.code,
        "zipUrl": os.path.join(release_path, "download", version.tag_name, MAGISK_MODULE_BUNDLED_PATH.name),
        "changelog": os.path.join(release_path, "tag", version.tag_name),
        "head_sha": head_sha,
    }


def build_magisk_module(version: VersionInfo, base_path: Path, bundle_path: Path) -> None:
    print("Building Magisk module at", bundle_path.relative_to(GITHUB_WORKSPACE))

    bundle_path.unlink(missing_ok=True)
    pkg_name = version.package_name

    customize_script_path = base_path / "customize.sh"
    meta_info_path = Path("META-INF") / "com" / "google" / "android"
    system_ext_path = Path("system") / "system_ext"
    app_path = system_ext_path / "priv-app" / OPENEUICC_APP_NAME / f"{OPENEUICC_APP_NAME}.apk"
    perms_path = system_ext_path / "etc" / "permissions" / f"privapp_whitelist_{pkg_name}.xml"

    with ReproducibleZipFile(bundle_path, "w", compression=ZIP_DEFLATED, compresslevel=9) as zip_file:
        zip_file.writestr(str(meta_info_path / "update-binary"), get_file_content(MODULE_INSTALLER_URL))
        zip_file.writestr(str(meta_info_path / "updater-script"), "#MAGISK\n", compress_type=ZIP_STORED)

        zip_file.writestr(str(app_path), OPENEUICC_APP_PATH.read_bytes(), compress_type=ZIP_STORED)
        zip_file.writestr(str(perms_path), get_file_content(OPENEUICC_PERMS_URL))

        zip_file.writestr("customize.sh", customize_script_path.read_text().format(
            PKG_NAME=pkg_name,
            APK_PATH=app_path,
            APK_NAME=os.path.basename(app_path)
        ))
        zip_file.writestr("uninstall.sh", list2cmdline(["pm", "uninstall", pkg_name]))
        zip_file.writestr("module.prop", build_module_prop(version))


def setup_github_output(**kwargs: str) -> None:
    if "GITHUB_OUTPUT" not in os.environ:
        return
    with open(os.environ["GITHUB_OUTPUT"], "w") as fp:
        fp.writelines(
            f"{name}={value}\n"
            for name, value in kwargs.items()
        )


def is_changed(workflow_run: WorkflowRun) -> bool:
    if GITHUB_EVENT_NAME == "workflow_dispatch":
        return True
    manifest = json.loads(UPDATE_JSON_PATH.read_text())
    return workflow_run.head_sha != manifest.get("head_sha")


def main():
    workflow_run = get_first_workflow_run()

    if workflow_run is None:
        print("No available workflow run found.")
        setup_github_output(changed="false")
        exit(0)

    if not is_changed(workflow_run):
        print("No changes detected.")
        setup_github_output(changed="false")
        exit(0)

    print("Latest workflow run number:", workflow_run.run_number)
    print("Latest workflow run HEAD:", workflow_run.head_sha)

    download_artifact(workflow_run.url, OPENEUICC_ARTIFACT_NAME)

    version_info = get_version_info()

    build_magisk_module(version_info, MAGISK_MODULE_PATH, MAGISK_MODULE_BUNDLED_PATH)

    update_json = json.dumps(build_update_json(version_info, workflow_run.head_sha), indent=2)
    UPDATE_JSON_PATH.write_text(update_json + "\n")

    with CHANGELOG_PATH.open("w") as fp:
        fp.write(CHANGELOG.format(
            head_sha=workflow_run.head_sha,
            head_sha_url=os.path.join(OPENEUICC_REPO_URL, "src", "commit", workflow_run.head_sha),
        ))

    setup_github_output(
        changed="true",
        tag_name=version_info.tag_name,
    )


if __name__ == '__main__':
    main()
